1. 基础功能实现
- 排行榜部分
    * 排行榜的底层当前使用redis的zset来实现，在执行分数更新时，通过公式将玩家分数与时间戳进行计算，用于确保玩家的操作顺序和排名一致。并且使用zset的相关方法（zadd，zrevrange，zrevrank）和lua脚本来保证操作的原子性。使用redis有以下好处：
        - 高性能&&微服务架构：redis是基于内存的缓存中间件，对于排行榜场景高度契合：吞吐量高，可以作为通用服务来支持不同业务服的访问
        - 原子性&&数据一致性：redis的数据操作基于单线程执行，且对于需求中的通过玩家id获取其周边排名的复合操作支持使用lua脚本执行以确保操作的原子性
        - 高可用&&完整性：redis支持主从复制和哨兵机制，保证数据的高可用，同时也支持快照和追加日志的方式保证数据的完整性

    * 以上选择是基于当前需求进行的选择，对于排序逻辑复杂，redis自带的zset无法满足需求的场景，可以考虑设计一个rank单点服来实现处理：
        - 高性能：数据结构部分使用跳表来满足排序和快速查找的需求
        - 微服务架构：使用单点服来进行逻辑的处理，使用rpc的方式支持不同业务服的访问
        - 原子性&&数据一致性：通过锁或者消息队列来保证操作的原子性
        - 高可用：可以使用主备模式来设计进行容灾设计
        - 完整性：通过定期数据落地和日志的方式来保证数据的完整性

    * 上述两种实现方式对比：
        | | Redis | 自定义服务 |
        |-|-|-|
        | 复杂度 | 大多数逻辑有对应实现，开箱即用 | 所有逻辑需要自行实现，复杂度高 |
        | 性能 | Redis作为高性能中间件被广泛使用 | 需要自行优化和压测进行性能测试 |
        | 通用性 | 数据结构固定，但能基本满足需求 | 可以按照需求进行自由设置 |
        | 价格 | 高 | 根据服务器性能决定，大部分情况下价格低于redis |
- 接口部分
    排行榜通用逻辑设计为接口，然后使用枚举或者实现一个排行榜管理类来进行管理，确保服务组件为单例存在。各个模块可以通过相同的接口去访问不同的排行榜实现。

2. 系统设计
- 可靠性需求
    * 玩家分数更新：分数持久化逻辑保存在玩家的数据结构中，排行榜每次使用玩家最新的分数进行数据的更新覆盖，而不使用排行榜的历史数据
    * 排行榜数据更新：可以设计一个定时任务，自动将各服玩家的数据抓取并提交，确保数据跟玩家数据和排行榜数据保持一致。
    * 玩家获取数据：排行榜的热点数据在各个玩家服上可能会进行二级缓存，用于防止redis压力过大。如果有这种设计的话可以在玩家修改排行榜之后对其他业务服进行广播，使缓存失效，在下次获取数据时重新从redis中获取。
- 性能需求
    * 在各个业务服上使用二级缓存，对排行榜的热点数据进行缓存。
    * 对更新操作进行优化，对于头部热点数据，使用实时更新确保数据的时效性。对于中后段的数据，使用消息队列进行异步更新，减少更新压力。

3. 需求更改
    * 分析给定需求的密集排名的设计逻辑，可知排名为所有玩家存在的分数的排名。分数的值域没有给出，所以按最通用的办法做
    * 定义一个zset类型rank用于和原版排行榜一样存储玩家的展示顺序
    * 定义一个zset类型scoreRank用于排序玩家所有的排行榜内分数，这个表用于获取玩家的实际排名
    * 定义一个hash类型scoreCount用于记录玩家的分数和出现次数
    * 修改分数时：从rank中获取玩家的旧分数oldScoreMillis，去除掉时间戳的部分得到oldScore，然后定义脚本传参的新分数newScoreMillis，取掉时间戳部分得到newScore。scoreCount对象对oldScore的计数-1，newScore的计数+1，并且在分数从0加到1时，往scoreRank中添加对应的分数，在分数计数变为0时，从scoreRank中删除对应的分数
    * 获取排名时：从rank中获取玩家的分数scoreMillis，去除掉时间戳的部分得到score，然后从scoreRank中获取对应的排名rank，这样就能得到密集排名逻辑下的玩家排名
